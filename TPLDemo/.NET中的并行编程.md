# .NET 中的并行编程

> Code：https://github.com/CuteLeon/TPLDemo
>
> Doc：https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-programming/

------

## 任务并行库 (TPL)

​	任务并行库 (TPL) 是 [System.Threading](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading) 和 [System.Threading.Tasks](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks) 空间中的一组公共类型和 API。

​	提供针对 [System.Threading.Tasks.Parallel](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.parallel) 类的文档（包括 `For` 和 `ForEach` 循环的并行版本），还提供了针对 [System.Threading.Tasks.Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 类的文档（描绘了表示异步操作的首选方式）。

> 如果某个循环在每次迭代时只执行少量工作，或它在很多次迭代时都不运行，那么并行化的开销可能导致代码运行更慢。
>
> 像任何多线程代码一样，并行化会增加程序执行的复杂性。



### 数据并行（任务并行库）

​	*数据并行*指的是对源集合或数组的元素同时（即，并行）执行相同操作的场景。 在数据并行操作中，对源集合进行分区，以便多个线程能够同时在不同的网段上操作。

​	任务并行库 (TPL) 支持通过 [System.Threading.Tasks.Parallel](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.parallel) 类实现的数据并行。 此类对 [for](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/for) 循环和 [foreach](https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/foreach-in) 循环（Visual Basic 中的 `For` 和 `For Each`）提供了基于方法的并行执行。

> 演示代码：https://github.com/CuteLeon/TPLDemo/blob/master/TPLDemo/ParallelDemo.cs



## 基于任务的异步编程

​	任务并行库 (TPL) 以“任务”的概念为基础，后者表示异步操作。 在某些方面，任务类似于线程或 [ThreadPool](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 工作项，但是抽象级别更高。 术语“任务并行”是指一个或多个独立的任务同时运行。 任务提供两个主要好处：

- 系统资源的使用效率更高，可伸缩性更好。

  在后台，任务排队到已使用算法增强的 [ThreadPool](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool)，这些算法能够确定线程数并随之调整，提供负载平衡以实现吞吐量最大化。 这会使任务相对轻量，你可以创建很多任务以启用细化并行。

- 对于线程或工作项，可以使用更多的编程控件。

  任务和围绕它们生成的框架提供了一组丰富的 API，这些 API 支持等待、取消、继续、可靠的异常处理、详细状态、自定义计划等功能。

出于这两个原因，在 .NET Framework 中，TPL 是用于编写多线程、异步和并行代码的首选 API。

### 隐式创建和运行任务

​	[Parallel.Invoke](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.parallel.invoke) 方法提供了一种简便方式，可同时运行任意数量的任意语句。 只需为每个工作项传入 [Action](https://docs.microsoft.com/zh-cn/dotnet/api/system.action) 委托即可。 创建这些委托的最简单方式是使用 lambda 表达式。 lambda 表达式可调用指定的方法，或提供内联代码。 

> [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 在后台创建的 [Invoke](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.parallel.invoke) 实例数不一定与所提供的委托数相等。 TPL 可能会使用各种优化，特别是对于大量的委托。

### 显式创建和运行任务

​	不返回值的任务由 [System.Threading.Tasks.Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 类表示。 返回值的任务由 [System.Threading.Tasks.Task<TResult>](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 类表示，该类从 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 继承。 任务对象处理基础结构详细信息，并提供可在任务的整个生存期内从调用线程访问的方法和属性。 例如，可以随时访问任务的 [Status](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.status) 属性，以确定它是已开始运行、已完成运行、已取消还是引发了异常。 状态由 [TaskStatus](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskstatus) 枚举表示。

​	在创建任务时，你赋予它一个用户委托，该委托封装该任务将执行的代码。 该委托可以表示为命名的委托、匿名方法或 lambda 表达式。

### 同步运行任务

​	在当前 TaskScheduler 上运行任务：task.RunSynchronously();

### 任务 ID

​	每个任务都获得一个在应用程序域中唯一标识自己的整数 ID，可以使用 [Task.Id](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.id) 属性访问该 ID。或者 Task.CurrentId 访问当前所在任务的 ID；

​	该 ID 是惰式创建的，这意味着它不会在被请求之前创建；

### 任务创建选项

| [TaskCreationOptions](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions) 参数值 | 说明                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [None](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions#System_Threading_Tasks_TaskCreationOptions_None) | 未指定任何选项时的默认值。 计划程序将使用其默认试探法来计划任务。 |
| [PreferFairness](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions#System_Threading_Tasks_TaskCreationOptions_PreferFairness) | 指定应当计划任务，以使越早创建的任务将更可能越早执行，而越晚创建的任务将更可能越晚执行。 |
| [LongRunning](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions#System_Threading_Tasks_TaskCreationOptions_LongRunning) | 指定该任务表示长时间运行的运算。                             |
| [AttachedToParent](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions#System_Threading_Tasks_TaskCreationOptions_AttachedToParent) | 指定应将任务创建为当前任务（如果存在）的附加子级。 有关详细信息，请参阅[附加和分离的子任务](https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-programming/attached-and-detached-child-tasks)。 |
| [DenyChildAttach](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions#System_Threading_Tasks_TaskCreationOptions_DenyChildAttach) | 指定如果内部任务指定 `AttachedToParent` 选项，则该任务不会成为附加的子任务。 |
| [HideScheduler](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions#System_Threading_Tasks_TaskCreationOptions_HideScheduler) | 指定通过调用特定任务内部的 [TaskFactory.StartNew](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory.startnew) 或 [Task.ContinueWith](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.continuewith) 等方法创建的任务的任务计划程序是默认计划程序，而不是正在运行此任务的计划程序。 |

​	可以通过使用位 **OR** 运算组合选项。

### 任务、线程和区域性

​	每个线程都具有一个关联的区域性和 UI 区域性，分别由 [Thread.CurrentCulture](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.thread.currentculture) 和 [Thread.CurrentUICulture](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.thread.currentuiculture) 属性定义。 线程的区域性用在诸如格式、分析、排序和字符串比较操作中。 线程的 UI 区域性用于查找资源。

​	除非使用 [CultureInfo.DefaultThreadCurrentCulture](https://docs.microsoft.com/zh-cn/dotnet/api/system.globalization.cultureinfo.defaultthreadcurrentculture) 和 [CultureInfo.DefaultThreadCurrentUICulture](https://docs.microsoft.com/zh-cn/dotnet/api/system.globalization.cultureinfo.defaultthreadcurrentuiculture) 属性在应用程序域中为所有线程指定默认区域性，线程的默认区域性和 UI 区域性则由系统区域性定义。如果你显式设置线程的区域性并启动新线程，则新线程不会继承正在调用的线程的区域性；相反，其区域性就是默认系统区域性。

>  对于指定 .NET Framework 4.6 之前的 .NET Framework 版本的应用，或者对于不指定 .NET framework 特定版本的应用，任务的区域性将继续由它运行的线程的区域性确定。

### 使用延续任务来链接任务

​	在异步编程中，一个异步操作在完成时调用另一个操作并将数据传递到其中的情况较常见。延续任务（也简称为“延续”）是一个异步任务，由另一个任务（称为 *前面的任务*）在完成时调用。

- **将数据从前面的任务传递到延续**。
- **指定将调用或不调用延续所依据的精确条件**。
- **在延续启动之前取消延续，或在延续正在运行时以协作方式取消延续**。
- 提供有关应如何计划延续的提示。
- **从同一前面的任务中调用多个延续**。
- 在多个前面的任务中的全部或任意任务完成时调用一个延续。
- **将延续依次相连，形成任意长度**。
- **使用延续来处理前面的任务所引发的异常**。

​	延续创建时的状态为 [WaitingForActivation](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskstatus#System_Threading_Tasks_TaskStatus_WaitingForActivation) 。 在一个或多个前面的任务完成时，它将自动激活。若在用户代码中对延续调用 [Task.Start](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.start) ，将引发 [System.InvalidOperationException](https://docs.microsoft.com/zh-cn/dotnet/api/system.invalidoperationexception) 异常。

​	延续本身是 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) ，并不阻止它在其上启动的线程。 调用 [Task.Wait](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.wait) 方法进行阻止，直到延续任务完成。

#### 为一个前面的任务创建延续

​	使用 [Task.ContinueWith](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.continuewith) 和 [Task.ContinueWith](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.continuewith) 方法，可以指定要在先行任务完成时启动的任务。 延续任务的委托已传递了对先行任务的引用，因此它可以检查先行任务的状态，并通过检索 [Task.Result](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result) 属性的值将先行任务的输出用作延续任务的输入。

#### 为多个前面的任务创建延续

​	还可以创建一个将在一组任务中的任意或全部任务完成时运行的延续任务。 若要在所有前面的任务都完成后执行延续，则可以调用静态 [Task.WhenAll](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.whenall) 方法或实例 [TaskFactory.ContinueWhenAll](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory.continuewhenall) 方法。 若要在多个前面的任务中的任意任务完成时执行延续，则可以调用静态 [Task.WhenAny](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.whenany) 方法或实例 [TaskFactory.ContinueWhenAny](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory.continuewhenany)方法。

​	调用 [Task.WhenAll](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.whenall) 和 [Task.WhenAny](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.whenany) 重载不会阻止调用线程。

#### 延续选项

​	在创建单任务延续时，你可以使用 [ContinueWith](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.continuewith) 重载，该重载采用 [System.Threading.Tasks.TaskContinuationOptions](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcontinuationoptions) 枚举值来指定启动延续所依据的条件。 

#### 将数据传递到延续

​	[Task.ContinueWith](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.continuewith) 方法将对前面的任务的引用以参数形式传递到延续的用户委托。 如果前面的任务是一个 [System.Threading.Tasks.Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 对象，并且任务在完成前保持运行，则延续可以访问任务的 [Task.Result](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result) 属性。

​	在任务完成之前，将阻止 [Task.Result](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result) 属性。 但是，如果任务已取消或出错，则尝试访问 [Result](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result) 属性将引发 [AggregateException](https://docs.microsoft.com/zh-cn/dotnet/api/system.aggregateexception) 异常。 可通过使用 [OnlyOnRanToCompletion](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcontinuationoptions#System_Threading_Tasks_TaskContinuationOptions_OnlyOnRanToCompletion) 选项避免此问题。

#### 取消延续

​	在以下情况下，延续的 [Task.Status](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.status) 属性将设置为 [TaskStatus.Canceled](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskstatus#System_Threading_Tasks_TaskStatus_Canceled) ：

- 延续引发 [OperationCanceledException](https://docs.microsoft.com/zh-cn/dotnet/api/system.operationcanceledexception) 以响应取消请求。 就像任何任务一样，如果异常包含已传递到延续的相同标记，则会将其视为确认协作取消。
- 将 [System.Threading.CancellationToken](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.cancellationtoken) 属性为 [IsCancellationRequested](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.cancellationtoken.iscancellationrequested) 的 `true`传递到延续。 在这种情况下，延续不会启动，并且将转换为 [TaskStatus.Canceled](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskstatus#System_Threading_Tasks_TaskStatus_Canceled) 状态。
- 延续由于其 [TaskContinuationOptions](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcontinuationoptions) 参数设置的条件未得到满足而从不运行。 例如，如果前面的任务进入 [TaskStatus.Faulted](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskstatus#System_Threading_Tasks_TaskStatus_Faulted) 状态，则该任务被传递了 [TaskContinuationOptions.NotOnFaulted](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcontinuationoptions#System_Threading_Tasks_TaskContinuationOptions_NotOnFaulted) 选项的延续将不会运行，而是将转换为 [Canceled](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskstatus#System_Threading_Tasks_TaskStatus_Canceled) 状态。

#### 继续和子任务

​	在前面的任务及其所有附加的子任务完成之前，延续将不会运行。 延续不会等待分离的子任务完成。

#### 将状态与延续关联

​	可以将任意状态与任务延续关联。 [ContinueWith](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.continuewith) 方法提供重载版本，每个重载版本都带有一个表示延续状态的 [Object](https://docs.microsoft.com/zh-cn/dotnet/api/system.object) 值。 可以之后通过使用 [Task.AsyncState](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.asyncstate) 属性访问此状态对象。 如果未提供值，则此状态对象为 `null` 。

#### 处理从延续中引发的异常

​	前面的任务与延续之间的关系不是父/子关系。 由延续引发的异常不会传播到前面的任务。 因此，请按在任何其他任务中处理异常的方式来处理由延续引发的异常。

### 已附加和已分离的子任务

​	子任务（或嵌套任务）是在另一个任务（称为“父任务”）的用户委托中创建的 [System.Threading.Tasks.Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 实例。 可以分离或附加子任务。 分离的子任务是独立于父级而执行的任务。 附加的子任务是使用 [TaskCreationOptions.AttachedToParent](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions#System_Threading_Tasks_TaskCreationOptions_AttachedToParent) 选项创建的嵌套任务。

​	下表列出了两种子任务之间的基本差异。

| 类别                           | 分离子任务 | 附加子任务 |
| :----------------------------- | :--------- | :--------- |
| 父级将等待子任务完成。         | No         | 是         |
| 父级将传播由子任务引发的异常。 | No         | 是         |
| 父级的状态取决于子级的状态。   | No         | 是         |

​	如果该子任务由 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 对象，而不是 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 对象表示，则你可以通过访问子任务的 [Task.Result](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result) 属性，确保父任务将等待子任务完成，即使该子任务是一个分离子任务。[Result](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result) 属性在其任务完成前会进行阻止。

​	父任务可以通过 TaskCreationOptions.DenyChildAttach 声明禁止附加子任务。

#### 创建分离的子任务

​	如果在任务中运行的用户代码创建一个新任务，且未指定 [AttachedToParent](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions#System_Threading_Tasks_TaskCreationOptions_AttachedToParent) 选项，则该新任务不采用任何特殊方式与父任务同步。 这种不同步的任务类型称为“分离的嵌套任务”或“分离的子任务”。

#### 创建子任务

​	如果任务中运行的用户代码在创建任务时指定了 [AttachedToParent](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions#System_Threading_Tasks_TaskCreationOptions_AttachedToParent) 选项，新任务就称为父任务的附加子任务。 因为父任务隐式地等待所有附加子任务完成，所以你可以使用 [AttachedToParent](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions#System_Threading_Tasks_TaskCreationOptions_AttachedToParent) 选项表示结构化的任务并行。

#### 子任务中的异常

​	如果分离子任务引发了异常，则该异常必须直接在父任务中进行观察和处理，正如任何非嵌套任务一样。 如果附加子任务引发了异常，则该异常会自动传播到父任务，并返回到等待或尝试访问任务的 [Task.Result](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result) 属性的线程。 因此，通过使用附加子任务，可以一次性处理调用线程上对 [Task.Wait](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.wait) 的调用中的所有异常。

#### 取消和子任务

​	任务取消需要彼此协作。 也就是说，若要取消任务，则每个附加或分离的子任务必须监视取消标记的状态。 如果想要通过使用一个取消请求来取消父任务及其所有子任务，则需要将作为自变量的相同令牌传递到所有的任务，并在每个任务中提供逻辑，以对每个任务中的请求作出响应。

### 等待任务完成

​	[System.Threading.Tasks.Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 和 [System.Threading.Tasks.Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 类型提供了 [Task.Wait](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.wait) 方法的若干重载，以便能够等待任务完成。 此外，使用静态 [Task.WaitAll](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.waitall) 和 [Task.WaitAny](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.waitany) 方法的重载可以等待一批任务中的任一任务或所有任务完成。

### 组合任务

​	[Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 类和 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 类提供多种方法，这些方法能够帮助你组合多个任务以实现常见模式，并更好地使用由 C#、Visual Basic 和 F# 提供的异步语言功能。

#### Task.WhenAll

​	[Task.WhenAll](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.whenall) 方法异步等待多个 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 或 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 对象完成。 通过它提供的重载版本可以等待非均匀任务组。

#### Task.WhenAny

​	[Task.WhenAny](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.whenany) 方法异步等待多个 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 或 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 对象中的一个完成。 与在 [Task.WhenAll](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.whenall) 方法中一样，该方法提供重载版本，让你能等待非均匀任务组。

​	[WhenAny](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.whenany) 方法在下列情境中尤其有用。

- 冗余运算。 请考虑可以用多种方式执行的算法或运算。 你可使用 [WhenAny](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.whenany) 方法来选择先完成的运算，然后取消剩余的运算。
- 交叉运算。 你可启动必须全部完成的多项运算，并使用 [WhenAny](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.whenany) 方法在每项运算完成时处理结果。 在一项运算完成后，可以启动一个或多个其他任务。
- 受限制的运算。 你可使用 [WhenAny](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.whenany) 方法通过限制并发运算的数量来扩展前面的情境。
- 过期的运算。 你可使用 [WhenAny](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.whenany) 方法在一个或多个任务与特定时间后完成的任务（例如 [Delay](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.delay)方法返回的任务）间进行选择。

#### Task.Delay

​	[Task.Delay](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.delay) 方法将生成在指定时间后完成的 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 对象。 你可使用此方法来生成偶尔轮询数据的循环，引入超时，将对用户输入的处理延迟预定的一段时间等。

#### Task(T).FromResult

​	通过使用 [Task.FromResult](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.fromresult) 方法，你可以创建包含预计算结果的 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 对象。 执行返回 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 对象的异步运算，且已计算该 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 对象的结果时，此方法将十分有用。

### 处理任务中的异常

​	当某个任务抛出一个或多个异常时，异常包装在 [AggregateException](https://docs.microsoft.com/zh-cn/dotnet/api/system.aggregateexception) 异常中。 该异常传播回与该任务联接的线程，通常该线程正在等待该任务完成或该线程访问 [Result](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1.result) 属性。 此行为用于强制实施 .NET Framework 策略 - 默认所有未处理的异常应终止进程。

​	联接线程也可以通过在对任务进行垃圾回收之前访问 [Exception](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.exception) 属性来处理异常。 通过访问此属性，可防止未处理的异常在对象完成时触发终止进程的异常传播行为。

### 任务取消

​	[Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 类支持协作取消，并与 .NET Framework 4 中新增的 [System.Threading.CancellationTokenSource](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.cancellationtokensource)类和 [System.Threading.CancellationToken](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.cancellationtoken) 类完全集成。 [System.Threading.Tasks.Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 类中的大多数构造函数采用 [CancellationToken](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.cancellationtoken) 对象作为输入参数。 许多 [StartNew](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory.startnew) 和 [Run](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.run) 重载还包括 [CancellationToken](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.cancellationtoken) 参数。

​	你可以创建标记，并使用 [CancellationTokenSource](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.cancellationtokensource) 类在以后某一时间发出取消请求。 可以将该标记作为参数传递给 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task)，还可以在执行响应取消请求的工作的用户委托中引用同一标记。

​	 可以使用以下选项之一终止操作：

- 简单地从委托中返回。 在许多情况下，这样已足够；但是，采用这种方式取消的任务实例会转换为 [TaskStatus.RanToCompletion](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskstatus#System_Threading_Tasks_TaskStatus_RanToCompletion) 状态，而不是 [TaskStatus.Canceled](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskstatus#System_Threading_Tasks_TaskStatus_Canceled) 状态。
- 引发 [OperationCanceledException](https://docs.microsoft.com/zh-cn/dotnet/api/system.operationcanceledexception) ，并将其传递到在其上请求了取消的标记。 完成此操作的首选方式是使用 [ThrowIfCancellationRequested](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.cancellationtoken.throwifcancellationrequested) 方法。 采用这种方式取消的任务会转换为 Canceled 状态，调用代码可使用该状态来验证任务是否响应了其取消请求。





### TaskFactory 类

​	[TaskFactory](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory) 类提供静态方法，这些方法封装了用于创建和启动任务和延续任务的一些常用模式。

- 最常用模式为 [StartNew](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory.startnew)，它在一个语句中创建并启动任务。
- 如果通过多个先行任务创建延续任务，请使用 [ContinueWhenAll](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory.continuewhenall) 方法或 [ContinueWhenAny](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory.continuewhenany) 方法，或它们在 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 类中的相当方法。 有关详细信息，请参阅[使用延续任务链接任务](https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-programming/chaining-tasks-by-using-continuation-tasks)。
- 若要在 `BeginX` 或 `EndX` 实例中封装异步编程模型 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 和 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 方法，请使用 [FromAsync](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory.fromasync) 方法。 有关详细信息，请参阅 [TPL 和传统 .NET Framework 异步编程](https://docs.microsoft.com/zh-cn/dotnet/standard/parallel-programming/tpl-and-traditional-async-programming)。

​	默认的 [TaskFactory](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory) 可作为 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 类或 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 类上的静态属性访问。 

​	你还可以直接实例化 [TaskFactory](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory) 并指定各种选项，包括 [CancellationToken](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.cancellationtoken)、[TaskCreationOptions](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions) 选项、[TaskContinuationOptions](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcontinuationoptions) 选项或 [TaskScheduler](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskscheduler)。 创建任务工厂时所指定的任何选项将应用于它创建的所有任务，除非 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 是通过使用 [TaskCreationOptions](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcreationoptions) 枚举创建的（在这种情况下，任务的选项重写任务工厂的选项）。

### 无委托的任务

​	在某些情况下，可能需要使用 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 封装由外部组件（而不是你自己的用户委托）执行的某个异步操作。 如果该操作基于异步编程模型 Begin/End 模式，你可以使用 [FromAsync](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskfactory.fromasync) 方法。 如果不是这种情况，你可以使用 [TaskCompletionSource](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.taskcompletionsource-1) 对象将该操作包装在任务中，并因而获得 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 可编程性的一些好处，例如对异常传播和延续的支持。

### 自定义计划程序

​	大多数应用程序或库开发人员并不关心任务在哪个处理器上运行、任务如何将其工作与其他任务同步以及如何在 [System.Threading.ThreadPool](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.threadpool) 中计划任务。 他们只需要它在主机上尽可能高效地执行。如果需要对计划细节进行更细化的控制，可以使用任务并行库在默认任务计划程序上配置一些设置，甚至是提供自定义计划程序。 

### 相关数据结构

​	TPL 有几种在并行和顺序方案中都有用的新公共类型。 它们包括 [System.Collections.Concurrent](https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.concurrent) 命名空间中的一些线程安全的、快速且可缩放的集合类，还包括一些新的同步类型（例如 [System.Threading.Semaphore](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.semaphore) 和 [System.Threading.ManualResetEventSlim](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.manualreseteventslim)），对特定类型的工作负荷而言，这些新同步类型比旧的同步类型效率更高。 .NET Framework 4 中的其他新类型（例如 [System.Threading.Barrier](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.barrier) 和 [System.Threading.SpinLock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.spinlock)）提供了早期版本中未提供的功能。 

### 自定义任务类型

​	建议不要从 [System.Threading.Tasks.Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 或 [System.Threading.Tasks.Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 继承。 相反，我们建议你使用 [AsyncState](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task.asyncstate) 属性将其他数据或状态与 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 或 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 对象相关联。 还可以使用扩展方法扩展 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task) 和 [Task](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.task-1) 类的功能。







## System.Threading.Tasks.Dataflow

[System.Threading.Tasks.Dataflow](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow) 命名空间提供基于角色的编程模型，用以支持粗粒度数据流和流水线操作任务的进程内消息传递。

### 类 

|类型|说明|
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [ActionBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.actionblock-1) | 提供数据流块，其调用为每个接收的数据提供的 [Action](https://docs.microsoft.com/zh-cn/dotnet/api/system.action-1) 委托。 |
| [BatchBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.batchblock-1) | 提供将输入批处理到数组中的数据流。                           |
| [BatchedJoinBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.batchedjoinblock-2) | 提供批处理指定数目输入的数据流块，这些输入为提供给目标的潜在不同的类型。 |
| [BatchedJoinBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.batchedjoinblock-3) | 提供批处理指定数目输入的数据流块，这些输入为提供给目标的潜在不同的类型。 |
| [BroadcastBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.broadcastblock-1) | 提供缓冲区，用于一次存储最多一个元素，在每个消息抵达时覆盖每个消息。 |
| [BufferBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.bufferblock-1) | 为[数据流](https://docs.microsoft.com/dotnet/standard/parallel-programming/dataflow-task-parallel-library)提供用于存储数据的缓冲区。 |
| [DataflowBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.dataflowblock) | 提供一组用于处理数据流块的静态方法（在 Visual Basic 中为共享方法）。 |
| [DataflowBlockOptions](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.dataflowblockoptions) | 提供选项，用于配置数据流块执行的过程。                       |
| [DataflowLinkOptions](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.dataflowlinkoptions) | 提供用于配置数据流块之间链接的选项。                         |
| [ExecutionDataflowBlockOptions](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.executiondataflowblockoptions) | 提供选项，用于配置数据流块执行的处理，这些块通过调用用户提供的委托处理每个信息。 这些是 [ActionBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.actionblock-1) 和 [TransformBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.transformblock-2)等数据流块。 |
| [GroupingDataflowBlockOptions](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.groupingdataflowblockoptions) | 提供选项，用于配置数据流块执行的处理，这些块有多个消息。 这些是 [JoinBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.joinblock-2) 和 [BatchBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.batchblock-1) 等数据流块。 |
| [JoinBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.joinblock-2) | 提供一个数据流块，该块联接多个数据流源，这些数据流源并不一定属于相同类型，会等待每个类型的一个项目到达，然后才作为包含每个类型的项目的元组完全释放。 |
| [JoinBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.joinblock-3) | 提供一个数据流块，它联接多个数据流源，这些数据流源并不一定属于相同类型，会等待每个类型的一个项目到达，然后才作为包含每个类型的项目的元组释放。 |
| [TransformBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.transformblock-2) | 提供数据流块，其调用为每个接收的数据提供的 [Func](https://docs.microsoft.com/zh-cn/dotnet/api/system.func-2) 委托。 |
| [TransformManyBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.transformmanyblock-2) | 提供数据流块，其调用为每个接收的数据提供的 [Func](https://docs.microsoft.com/zh-cn/dotnet/api/system.func-2) 委托。 |
| [WriteOnceBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.writeonceblock-1) | 在数据流块网络中为接受和存储最多一个元素提供缓冲区。         |

### 结构 

|类型|说明|
| ------------------------------------------------------------ | ------------------------------------------ |
| [DataflowMessageHeader](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.dataflowmessageheader) | 提供数据属性容器，用于在数据流块之间传递。 |

### 接口 

|类型|说明|
| ------------------------------------------------------------ | ------------------------------------------ |
| [IDataflowBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.idataflowblock) | 表示数据流块。                           |
| [IPropagatorBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.ipropagatorblock-2) | 表示数据流块，其为数据和数据源的目标。   |
| [IReceivableSourceBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.ireceivablesourceblock-1) | 表示数据流块，其支持接收消息，无需链接。 |
| [ISourceBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.isourceblock-1) | 表示数据流块，其为数据源。               |
| [ITargetBlock](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.itargetblock-1) | 表示数据流块，其为数据目标。             |

### 枚举 

|类型|说明|
| ------------------------------------------------------------ | ------------------------------------------ |
| [DataflowMessageStatus](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.dataflowmessagestatus) | 表示在数据流块间传递时 [DataflowMessageHeader](https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.tasks.dataflow.dataflowmessageheader)的状态。 |

### 注解

TPL 数据流库 (System.Threading.Tasks.Dataflow 命名空间）不随 .NET 一起分发。请在线搜索 `System.Threading.Tasks.Dataflow` 包。

